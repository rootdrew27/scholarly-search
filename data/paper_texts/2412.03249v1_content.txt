SECTION: MLQM: Machine Learning Approach for Accelerating Optimal Qubit Mapping

Quantum circuit mapping is a critical process in quantum computing that involves adapting logical quantum circuits to adhere to hardware constraints, thereby generating physically executable quantum circuits. Current quantum circuit mapping techniques, such as solver-based methods, often encounter challenges related to slow solving speeds due to factors like redundant search iterations. Regarding this issue, we propose a machine learning approach for accelerating optimal qubit mapping (MLQM). First, the method proposes a global search space pruning scheme based on prior knowledge and machine learning, which in turn improves the solution efficiency. Second, to address the limited availability of effective samples in the learning task, MLQM introduces a novel data augmentation and refinement scheme, this scheme enhances the size and diversity of the quantum circuit dataset by exploiting gate allocation and qubit rearrangement. Finally, MLQM also further improves the solution efficiency by pruning the local search space, which is achieved through an adaptive dynamic adjustment mechanism of the solver variables. Compared to state-of-the-art qubit mapping approaches, MLQM achieves optimal qubit mapping with an average solving speed-up ratio of 1.79 and demonstrates an average advantage of 22% in terms of space complexity.

Quantum circuit mapping is a critical process in quantum computing that involves adapting logical quantum circuits to adhere to hardware constraints, thereby generating physically executable quantum circuits. Current quantum circuit mapping techniques, such as solver-based methods, often encounter challenges related to slow solving speeds due to factors like redundant search iterations. Regarding this issue, we propose a machine learning approach for accelerating optimal qubit mapping (MLQM). First, the method proposes a global search space pruning scheme based on prior knowledge and machine learning, which in turn improves the solution efficiency. Second, to mitigate the scarcity of effective samples in the learning task above, MLQM incorporates a data augmentation and refinement scheme. This scheme enhances the size and diversity of the quantum circuit dataset by exploiting gate assignment and qubit rearrangement. Finally, MLQM also further improves the solution efficiency by pruning the local search space, which is achieved through an adaptive dynamic adjustment mechanism of the solver variables. Compared to state-of-the-art qubit mapping approaches, MLQM achieves optimal qubit mapping with an average solving speed-up ratio of 1.79 and demonstrates an average advantage of 22% in terms of space complexity.

[1]organization=The School of Electronic Science and Engineering, University of Electronic Science and Technology of China,addressline=No.2006, Xiyuan Ave,
city=Chengdu,
postcode=611731,
country=China

[2]organization=The School of Information and Software Engineering, University of Electronic Science and Technology of China,city=Chengdu,
postcode=611731,
country=China

[3]organization=The School of Physics, University of Electronic Science and Technology of China,city=Chengdu,
postcode=611731,
country=China

[4]organization=The School of Computer Science and Engineering, University of Electronic Science and Technology of China,city=Chengdu,
postcode=611731,
country=China

MLQM introduces a machine learning approach with novel data augmentation, significantly reducing the quantum circuit mapping search space.

An adaptive hyperparameter mechanism dynamically transforms search trends into constraints, enhancing mapping efficiency.

Experiments show MLQM achieves 1.79× solving time speedup and 22% memory reduction, advancing quantum circuit optimization.

SECTION: 1Introduction

Quantum computing has the potential to solve complex problems that are intractable for classical computers[1,2,3,3,4], and its technical research and industrialization process have achieved initial successes in the NISQ era[5,6,7]. Among the various technological approaches to implementing quantum computing[8,9,6], superconducting quantum circuits have emerged as one of the most prevalent due to their advantages in designability and scalability[10]. To ensure the correct execution of quantum programs on superconducting quantum computers, logic synthesis and qubit mapping are two fundamental processes. Logic synthesis involves decomposing high-level gates in quantum programs into single-qubit or two-qubit gates supported by the quantum hardware. Qubit mapping, also known as layout synthesis, is employed to insert swap gates into quantum circuits to satisfy the hardware connectivity constraints of the quantum computer. The evaluation metrics of qubit mapping include circuit depth, number of swap gates, fidelity, etc., and the optimal qubit mapping refers to a mapping in which one or more metrics above are optimal.

In previous research, methods for addressing the qubit mapping problem can be broadly categorized into two classes: heuristic methods and solver-based methods. Heuristic methods[11,12,13,14,15,16,17]utilize meta-heuristic algorithms to determine quantum circuit mapping schemes, with a notable example being the SABRE method proposed by Gushu Li et al.[12]. While heuristic methods generally exhibit excellent execution speeds, the solutions obtained are often far from optimal and lack sufficient interpretability[18], leading to limited practicality.

Solver-based approaches to the qubit mapping problem involve transforming the problem into a satisfiability modulo theories (SMT) problem, encoding the objective as constraints, and employing solvers to search for solutions that satisfy the constraints[19,20,21,22]. Robert Wille first proposed utilizing solver-based Pseudo Boolean Optimization to achieve the optimal number of swap gates in 2014[22]. In 2020, Bochen Tan et al. treated layout synthesis as a mathematical optimization problem and employed time-space variable encoding to obtain solutions with either optimal depth or optimal swap gate count[21]. They also proposed a coarse-grained time model called TB-OLSQ, which reduced time consumption, but the optimality of the circuit depth could not be guaranteed. One year later, Bochen Tan et al. introduced a solver-based approach based on gate absorption methods, using solver constraints to find swap gates absorbable bygates[20]. Qubit mapping approaches combined solver methods and heuristics were also proposed to address the problem. Abtin Molavi et al. proposed a qubit mapping method considering the problem as a MaxSAT problem[23], and local relaxation and cyclic circuit relaxation techniques were applied to reduce time consumption. Tsou-An Wu et al. proposed a divide-and-conquer method, using greedy algorithms to partition the quantum circuit into circuit blocks[19], applying solvers within the blocks to find feasible mappings, and employing heuristic methods to find swap gate insertion methods between circuit blocks. Although the time consumption was reduced in heuristic-solver combined approaches, the heuristic part made the methods difficult to find depth-optimal solutions.

In summary, as the most promising and practically applied method for quantum computers, solver-based quantum qubit mapping approaches have made substantial progress. However, while obtaining better solutions, the increased search time of solver-based methods has become a pressing issue. The state-of-the-art solver-based method, OLSQ2[24], proposes an iterative approach to solve for the optimal depth and swap gate count, reducing the solution time by simplifying the variable counts and employing a more efficient method of encoding variables and constraints. Nevertheless, there is still room for improvement in this method. In OLSQ2, each global search targeting all candidate solutions consumes significant time, but only the two searches closest to the optimal solution provide practical benefits. Based on the above observations, it is efficient and reasonable to improve the solution efficiency by pruning the solver’s search space.

In this work, we propose a machine learning-based approach for accelerating optimal qubit mapping (MLQM) using quantum circuit feature datasets. By constructing quantum circuit feature datasets based on quantum circuits and employing data augmentation and refinement techniques, MLQM aims to provide prior knowledge about the circuit depth and swap gate count using machine learning before the solver’s optimization process and conducts the global search space pruning. The scheme allows the global search over all candidate mapping solutions to start from an initial state closer to the optimal circuit depth and swap gate count. Furthermore, MLQM optimizes the local search process within the solver for constraint verification of candidate mapping schemes, ultimately achieving a comprehensive improvement in the efficiency of quantum circuit mapping.

The main contributions of this work are as follows:

MLQM innovatively introduces a concise and efficient machine learning approach to the quantum circuit mapping problem, providing high-quality prior knowledge to the solver. With a tailored data augmentation method, MLQM significantly reduces the global search space and accelerates the solving process.

MLQM proposes an adaptive adjustment mechanism for solver hyperparameters, which converts search trends into dynamic constraints, reduces the local search space and substantially enhances mapping efficiency.

Extensive comparative experiments on widely used quantum computer architectures and circuits demonstrate that MLQM achieves an average speedup ratio of 1.79 in solving time and an average reduction of 22% in memory footprint compared to state-of-the-art methods while ensuring optimal mapping quality. These results showcase MLQM’s ability to expand the advantages of solver-based methods further and it’s potential for solving quantum circuit optimization problems.

SECTION: 2Background

In this section, we elucidate the concepts related to qubit mapping and solvers and the application of solver methods in qubit mapping.

SECTION: 2.1Qubit mapping

Qubit mapping refers to mapping or routing qubits in a quantum program to physical qubits in a quantum computer, ensuring that they satisfy the connectivity constraints of the quantum computer, thus rendering the quantum circuit executable[12]. The qubit mapping problem has two inputs: the first is the quantum circuit, and the second is the coupling graph, which represents the connectivity of the quantum computer. A coupling graph is a graph, whereis the set of physical qubits, andis a set consisting of tuples, whereandare two physical qubits, indicating the presence of edges between them. Only the pairs of physical qubits connected by edges incan support two-qubit gates.

The process of qubits mapping requires particular attention to three essential tasks: proper initial mapping, connectivity compliance, and time compaction as follows:

Proper Initial MappingQuantum computer systems can be divided into a physical qubit layer and a logical qubit layer[25], representing quantum computer features and quantum circuit programs, respectively. Initial mapping refers to mapping logical qubits to physical qubits, enabling a quantum program to run on a quantum computer. Fig.1LABEL:sub@qm_beforeillustrates the initial mapping process of logical qubits to physical qubits as.

Connectivity ComplianceConnectivity Compliance involves inserting swap gates into the quantum circuit to satisfy the connectivity requirements of the quantum computer[26]. As shown in Fig.1, a swap gate, composed ofCNOT gates, can exchange the two logical qubits it operates on, thereby adjusting the mapping between logical and physical qubits. Fig.1LABEL:sub@qm_afterillustrates the routing process: gatestocan operate properly because each acts on connected physical qubits or they are single-qubit gates, butacts onand, violating the connectivity. Therefore, a swap gate is inserted onandto address this issue, adjusting the mapping to. After this,acts on the connected physical qubitsand. Connectivity compliance has a significant impact on the depth of quantum circuits.

Time CompactionTime Compaction focuses on adjusting the execution time of each quantum gate to make the quantum circuit depth as shallow as possible, and its process must satisfy the sequence of gates in the quantum circuit. As shown in Fig.1LABEL:sub@qm_dag,andhave no dependency constraints, so they can be arranged to execute in parallel rather than one after another, reducing the execution time of the circuit and increasing the utilization of qubits. The longest dependency chain (LDC) is another important concept in qubit mapping, marked in red in Fig.1LABEL:sub@qm_dag.

It is worth noting that after qubit mapping, the circuit’s length increased from 9 to 12 due to the additional insertion of swap gates. Solver-based methods can achieve a qubit mapping solution with optimal depth and the minimum number of swap gates to ensure circuit fidelity[24]. However, more efficient solver-based schemes are necessary for quantum circuits with a larger number of qubits and greater depth to mitigate the computational complexity and resource requirements.

SECTION: 2.2Solver

Solvers are tools for determining the satisfiability of formulas in SMT and Boolean Satisfiability (SAT) theories[27]. In the context of qubit mapping tasks, solver methods can be employed to formulate the mapping problem as a constraint satisfaction or optimization problem. By encoding the constraints of the qubit mapping problem into a formulation the solver understands, it becomes possible to search for feasible mappings that satisfy the given constraints. Among them, the search for all mapping schemes of the current circuit can be regarded as a global search. In contrast, the search for mapping schemes under constraint conditions is considered a local search, both of which have a crucial impact on search efficiency.

The inputs of a solver typically comprise variables reflecting the values in the qubit mapping problem, along with a set of constraints and objectives relevant to the problem. The following variables are defined to match the qubit mapping problem:

The variablerepresents the set of physical qubits, which are mapped from logical qubitsat time, where the variableranges from 0 to, an artificial set value that limits the execution time of all quantum gates.

The swap gate execution time variables set is, wheredenotes the edge in the coupling graph andrepresents gate execution time, and the variablealso ranges from 0 to.

The set of time variablesrepresents the execution times of quantum gates, with each element indicating the moment of execution of gate.

All the above variables are of the same type as[24]. Namely, variables inandare bit vectors, while variables inare boolean variables. After the variable creation, the following constraints will be added to the solver:

Mapping Constraint: If, thenmust equal to a physical qubit, whereandare the sets of all logical qubits and all physical qubits, respectively. Additionally, at the same time step, multiple logical qubits cannot be mapped to the same physical qubit.

Gate Execution Constraint: The qubit pair of any two-qubit gate must be mapped to an edge inat the two-qubit gate execution time.

Execution Order Constraint: The execution order of gates after mapping must adhere to the execution order of gates in the logical quantum circuit.

Swap Gate Constraint: All swap gates must not have time overlap with other swap gates or logical quantum gates if they operate simultaneously.

Mapping Transformation Constraint: Ifandare two logical qubits of a swap gate, thenandwill exchange their values after the completion time of the swap gate.

SECTION: 2.3Solve Optimal Qubit Mapping Problem with Solver

The conventional methodology for attaining the optimal qubit mapping, as outlined in[24], begins by setting a specific depth limitationas an additional constraint. This limitation is then adjusted based on the solver’s checking result until the optimal depth is reached. Once the optimal depth is determined, it becomes a fixed constraint, and the optimization goal shifts to minimizing the number of swap gates, denoted as. The procedure for identifying the optimal number of swap gates closely mirrors the depth determination process. Ultimately, the solution that simultaneously satisfies both the optimal depth and the minimal number of swap gates under the optimal depth constraint can be considered the optimal qubit mapping.

SECTION: 3Approach

In this section, we will first present an analysis of the problem in current qubit mapping approaches, followed by an exposition of our proposed approach, which encompasses construction of quantum circuit feature dataset, model architecture, prediction, training procedures and solving process.

SECTION: 3.1Motivation

The OLSQ2 algorithm is the state-of-the-art solver-based optimal qubit mapping algorithm[24], which proposes an iterative approach to solving for the optimal depth and swap number and reduces the solution time by simplifying the variable counts and employing an efficient method of encoding variables and constraints. However, the approach still has room for improvement. In OLSQ2, each search consumes a significant amount of time, but only the last two searches are valid because they determine the optimal solution. If the number of useless searches can be minimized, then the solution time will also be reduced significantly. Fig.2runs OLSQ2 on seven circuits from the quantum benchmark dataset QASMBench[28]and demonstrates the benefits of reducing search counts. Comparing the time consumption between OLSQ2 and minimizing search counts, a maximum of 71.1% and an average of 43.8% reduction in time consumption can be achieved by minimizing the search count. Furthermore, qubit mapping depends solely on the execution order and type of quantum gates (single-qubit gate or two-qubit gate) of the quantum circuit and the coupling graph of quantum computers. Thus, the time required for extracting metrics from the quantum circuit is negligible compared to the time required in qubit mapping using solver-based methods, which means the prediction process is fast and real-time.

Based on these observations, it is reasonable to predict the optimal qubit mapping using prior knowledge of the quantum circuit. The proposed qubit mapping method is illustrated in Fig.3. By constructing datasets of quantum circuit features, we aim to predict the circuit depth and the number of swap gates beforehand. This approach allows us to start the search from an initial state closer to the optimal circuit depth and swap gate count, reducing the number of searches and ultimately improving efficiency.

SECTION: 3.2Construction of the Quantum Circuit Feature Dataset

Our quantum circuit feature dataset is constructed based on the QASMBench dataset provided in[28]. This dataset integrates quantum circuits commonly used in chemistry, simulation, search, optimization, and machine learning. Due to noise and gate imperfections, quantum computers can only reach a finite depth before the advent of total decoherence[29], rendering excessively long quantum circuits impractical. Therefore, we choose the quantum circuits in the QASMBench dataset whose qasm file’s size is less than 2KB for feature extraction and labeling. Unfortunately, the number of quantum circuits meeting this requirement in the QASMBench dataset does not exceed 50, making it nearly impossible to train a model with sufficient accuracy on such a small dataset. To address this issue, we propose a method for enhancing quantum circuit datasets from circuits that do not meet the length requirement. This method involves two steps: gate allocation and qubit reordering.

In gate allocation, for every large quantum circuitin the quantum circuit dataset, we sequentially search its quantum gates and append the gates to an empty setone by one until the number of elements in the set reaches an upper bound, thenis saved to, all elements inwill proceed to qubit reordering. It’s worth noting thatis a dynamic value in a set, which dramatically enhances the diversity of circuits. Additionally, splitting quantum circuits by sizemay lead to residuals in the circuit since the number of gates in a quantum circuit may not necessarily be the sum of dynamic valuesin. For each residual, if it contains at least one two-qubit gate, it will be recorded in. In the qubit reordering section, the qubits of each quantum circuit inare renumbered while preserving the gate dependency relationships, ensuring the circuits are adapted for subsequent processing. The steps for dataset enhancement are shown in Algorithm1.

To comprehensively describe the properties of quantum circuits in the context of the qubit mapping problem, circuit depth and circuit width are included in the features as the most intuitive and fundamental characteristics of quantum circuits first. Additionally, max qubit depth and operation density are added since they provide insights into how gates are spread across the quantum circuit. Furthermore, the two-qubit gate count and entanglement variance are incorporated into the feature set, as the arrangement of two-qubit gates is central to the qubit mapping problem. A more detailed explanation of these features and their relation to the qubit mapping problem is as follows:

Circuit depth: This metric represents the length of the longest dependency chain(LDC) in the quantum circuit, given by (1), an example of LDC is shown in Fig.1LABEL:sub@qm_dag. LDC determines the lower bound of the circuit depth after qubit mapping.

Circuit width: This metric refers to the number of qubits present in the quantum circuit and defined in (2).

Max qubit depth: Max qubit depth is obtained by counting the total number of gates on each qubit and selecting the maximum among them, shown in (3), whererepresents the number of quantum gates on different qubits.

Operation density: Which is also known as gate density, refers to the occupancy rate of quantum gates in both the time and space dimensions of the qubits. A higher operation density will increase the circuit depth and the number of required swaps after qubit mapping. The formula for calculating the operation density is given by (4), wheredenotes the count of single-qubit gates, andrepresents the count of two-qubit gates in the quantum circuit.

Two-qubit gate number: The two-qubit gate number is defined as the count of two-qubit gates present in the quantum circuit. Typically, an increase in the number of two-qubit gates will lead to higher circuit depth and a more significant number of required swaps after mapping when other parameters remain constant:

Entanglement variance: Entanglement variance describes the uneven distribution of two-qubit gates across different qubits. Qubit mappings with larger entanglement variance will benefit more from the qubit mapping process. This concept is captured by (6), whererepresents the number of two-qubit quantum gates on qubit, whiledenotes the average number of two-qubit quantum gates across all qubits.

Further exploration of features is demonstrated inA. After feature extraction, the optimal depth and the minimum number of swap gates are calculated for each sample using OLSQ2. Subsequently, based on the result and the existing features, we constructed two quantum circuit feature datasets, taking the depth and the number of swap gates of quantum circuits as their labels, respectively. The feature datasets are available after the data refinement process, which uses the AllKNN algorithm to process each sample iteratively[30]. The algorithm retains each sample by examining the types of itsnearest neighbors, withincrementally increasing from 1. This approach mitigates data imbalance, enhancing the datasets’ suitability for predicting depth and swap gate numbers. The constructed datasets are detailed inB.

SECTION: 3.3Model Training and Prediction

Considering the relatively small size of our dataset and the interpretability and training efficiency of the model, we employ a tree regression model for label prediction. The following loss functionis minimized to determine the feature and its split point at each step of the tree partitioning process:

Here,is the number of samples,represents the feature being split,is the value used in feature splitting,is the number of samples less than, andrefers to the number of samples greater thanafteris split.represents the feature values less than or equal to and greater thanafteris split. During the model training process, the algorithm attempts to find the splitting method that minimizes the loss function. After training, the predicted depthand the predicted swap gate numberof a quantum circuit are obtained. Examples of tree regression models for circuit depth and swap number prediction are presented inA.

SECTION: 3.4Solving

The solver is iteratively utilized to find the optimal qubit mapping with Microsoft’s Z3 solver[27]. Considering the optimal circuit depth after qubit mapping cannot be less than the length of the LDC, the initial value of the depth searching is initialized to. The swap number search initializes atto ensure the selected swap number does not exceed the current optimal value, withrepresenting the swap number from the previous satisfactory formulation in the search process. Subsequently, the search program incrementally adjusts these values in 2-unit steps to balance computational efficiency and solution accuracy. Once a transition is detected in the formulation’s satisfiability, indicating the search has reached a critical boundary, the program determines the optimal solution by meticulously verifying the intermediate values between depth constraints. As illustrated in Fig.4, during a depth searching process where the formulation proves unsatisfiable at depth 23 and satisfiable at depth 25, the algorithm sets the depth constraint to 24 for subsequent verification. If the formulation remains satisfiable, 24 is confirmed as the optimal depth; otherwise, 25 is retained .Similarly, the swap gate search process employs an identical optimization strategy as the depth search process. Fig.4also demonstrates the search reduction of MLQM, wherein depth search iterations are diminished by 1 and swap search iterations are diminished by 2 relative to OLSQ2.

Another improvement to our article is derived from the following observation: in experiments, we note that the solving efficiency of the solver decreases with an increase of two factors: the number of variables and the number of bits in the bit vector variables. In[24], the size of the second dimension ofandand the bit number of variables inare according to 1.5 times the length of LDC. However, the method does not consider the asynchrony between,and, and the reduction in search space as the circuit depth decreases.

We propose a method that increases the solving efficiency by pruning the local search space. More specifically, the method finely and dynamically adjusts the size of the time dimension ofand, as well as the size of the bit vectors in. First, we define six variables:as the depth of the circuit verified in step,as the number of binary digits of every variable’s size in,as the size of the time dimension ofand, which must be larger than,as the threshold value for circuit depth, and the last two variableandare step size of.

After each solving process, the program will make a judgment based on the satisfiability of the formation. As algorithm2demonstrated, the solver’s constraints will be adjusted under either of the two following situations. The first situation iscontinuing to grow and reaching, or its binary value exceeds. If this situation is triggered by the first condition,will be adjusted based on its value relative to. Ifis larger than,will be set to, otherwise, it will be set to, where. The strategy is based on an observation: circuits with smaller depth usually require fewer search iterations to find the optimal solution. Similarly,will also be adjusted if. After that, variablesandwill be updated by variable,will be updated by, and the solver’s constraints will also be re-added. Another situation is the number of binary digits ofis less than the number of binary digits of. Then,,and the solver’s constraints will also be updated to accommodate the value of. Ultimately, leveraging the MLQM approach enables the derivation of the optimal qubit mapping solution after depth searching and swap gate number searching, and the solving efficiency is greatly improved.

SECTION: 4Experimental Results

SECTION: 4.1Experimental Settings

In this section, we demonstrate the performance of the proposed solution relative to other baselines. Our method runs in a Python 3.6 environment, utilize the Z3 solver’s Python API (v4.13.0.0) for constraint solving and the python-SAT library (v0.1.8.dev12) for constraint adding. We employ scikit-learn’s Python API (v0.24.2) and imbalanced-learn (v0.8.1) for model training and dataset refinement. All experiments are conducted on an AMD Ryzen7 5700G CPU running at 3.8GHz with 32GB of RAM.

We design two experiments to validate our method’s efficiency and optimality. The first part compares our method’s solving time and memory consumption and the latest solver-based approach, OLSQ2[24]. The second part compares our method and the leading representative heuristic method, SABRE[12].

In constructing the quantum circuit feature dataset, the QASMBench dataset is enhanced through the utilization of a method of generating quantum circuit datasets twice, which expands and ensures diversity within the dataset. All single-qubit and two-qubit gates are retained in the first utilization, with a dynamic parameterless than 100. In the second utilization, only two-qubit gates are maintained, withless than 30. To avoid overfitting, the max depth of the tree regression model is set to 5.

The training set is built from the remaining portion of the quantum circuit feature dataset after the test set is removed. To comprehensively validate our approach, we perform experiments using five coupling graphs: Google’s Sycamore with 54 qubits, IBM’s Rochester and Melbourne with 53 and 14 qubits respectively, Rigetti’s Aspen-4 with 16 qubits, and a 5x5 grid coupling graph with 25 qubits, as shown in Fig.5. All coupling graphs above are commonly used in qubit mapping verification. For the test set, considering the limited size of the original dataset, eight quantum circuits in QASMbench’s original dataset are used, with qubit numbers ranging from 3 to 40 and qubit gates ranging from 25 to 107. The number in every sample’s name represents the logical qubit numbers, for example, sample “bv_n14” has 14 qubits. For Sycamore and Rochester, all eight samples are used as test set. For Aspen-4, IBM-Melbourne and 5x5 grid, due to their qubit numbers, the samples in the test set with fewer qubits than their qubit counts are used.
In the solving process,,andare set to 50, 15, and 10 respectively to maintain solving efficiency and avoid unnecessary re-adding of variables and constraints.

SECTION: 4.2MLQM versus OLSQ2

To validate the efficiency of MLQM, we compare the runtime of MLQM with OLSQ2, the results of these samples are shown in Fig.6. And the detailed time consumption for each sample is listed in the first column of Table1to Table5, the numbers of searches are also shown in these tables. MLQM has an acceleration ratio of up to 6.78, which appears in the sample “cat_n35” on Sycamore. Generally, MLQM achieves an average acceleration ratio of 1.79, shows higher solution efficiency in most samples, especially for coupling graphs with more physical qubits and quantum circuit with more logical qubits, i.e., samples on Sycamore and IBM-Rochester. Furthermore, the number of searches for OLSQ2 increases dramatically with the number of qubits required for the sample on every coupling graphs, for example, quantum circuits with 14, 23, and 35 qubits require 17, 29 and 40 searches respectively processed by OLSQ2 method on Sycamore.
In contrast, MLQM shows consistently excellent performance with a significant reduction in searches, even for those circuits and coupling graphs with many qubits, the average number of searches for MLQM is 6.56. By comparing the speed-up ratio of MLQM (displayed in parentheses after the time consumption of MLQM) with the percentage reduction in the number of searches of MLQM, it can be seen that samples with a higher percentage reduction of the number of searches also usually have higher speed-up ratios. The observation verifies our previous conjecture that it is reasonable and feasible to reduce the time consumption of qubit mapping by pruning the search space. Furthermore, in all cases, MLQM maintains no more than 12 searches, demonstrating excellent scalability. With respect to solution quality, both MLQM and OLSQ2 algorithms prioritize depth optimality in their initial search, subsequently refining solutions for swap number optimality, thereby ensuring MLQM’s optimality.

Table1to Table5also present the memory footprint comparison between MLQM and OLSQ2, highlighting MLQM’s space efficiency. With an average 22% reduction in memory usage, MLQM demonstrates a smaller memory footprint than OLSQ2 in most samples.
The memory reduction is especially prominent on coupling graphs with more physical qubits. On Sycamore, OLSQ2 consumed up to 5369 MB of memory, while MLQM required only 3286 MB, marking a significant 38.8% reduction. MLQM also exhibits remarkable space efficiency across various architectures, achieving substantial memory footprint reductions for samples exceeding 4,000 MB on OLSQ2. Similar to the solving efficiency, the spatial efficiency improvement of the MLQM also exhibits an increase with logic and physical qubits, which underscores MLQM’s robust scalability concerning space efficiency, particularly as the memory requirements increase.

SECTION: 4.3MLQM versus SABRE

To demonstrate the quality of MLQM, the mapped circuit depths of MLQM with the heuristic method SABRE[12]are compared, and the results are shown in Fig.7to Fig.11. MLQM achieves an average of 52.2%, 39.1%, 27.2%, 27.0% and 33.6% depth reductions on Sycamore, IBM-Rochester, Aspen-4, IBM-Melbourne and 5x5 grid architecture respectively, and the overall average depth reduction across all coupling graphs is 35.8%. It is worth noting that as the coupling graph’s qubit number increases, the depth improvement of MLQM becomes more and more obvious. Similarly, the advantage of high-quality solutions provided by MLQM is more pronounced as the number of qubits of the quantum circuits increases for a fixed coupling architecture, which is clearly demonstrated in most figures.

The number of swap gates used in qubit mapping with SABRE is compared to the proposed MLQM approach across various architectures in Fig.12to Fig.16. MLQM achieves a significant reduction in the average number of swap gates by 81.3%, 58.7%, 28.0%, 23.5%, and 39.6% on the Sycamore, IBM-Rochester, Aspen-4, IBM-Melbourne, and 5x5 grid architectures, respectively. The overall average depth reduction across all coupling graphs is 46.2%. The result shows that the competitiveness of the solutions of MLQM is increasing for coupling graphs with more physical qubits.
Notably, MLQM attains a 100% reduction in the number of swap gates for seven samples on the Sycamore, IBM-Rochester, and 5x5 grid architectures, indicating that no additional gates are introduced, thus preserving circuit fidelity.
To demonstrates the effectiveness of MLQM more intuitively, a comparison between SABRE and MLQM on the “bv_n14” are shown in sample (Fig.17LABEL:sub@sabre_circand Fig.17LABEL:sub@mlqm_circ). Comparing with SABRE, MLQM produces more compact circuits, higher qubit utilization, and significantly reduced circuit lengths. In addition, it also avoids the extensive use of auxiliary qubits in SABRE. In general, MLQM transforms quantum programs into shorter and more compact circuits that use fewer qubits. The advancement contributes to enhancing the success rate of quantum circuit on real quantum devices, reducing the resource utilization demands on quantum computers, and augmenting the parallel processing capabilities of quantum programs.

SECTION: 5Discussion

MLQM proposes a new solution to address the trade-off between accuracy and efficiency encountered by conventional qubit mapping methods, contributing to the resolution of the prevalent scalability issue that optimal qubit mapping algorithms face. This work provides novel research perspectives and benchmarks for further optimization of quantum circuit mapping algorithms, demonstrating the potential for application on larger-scale quantum circuits and more complex quantum computer architectures, thus facilitating the practicality of quantum computing.
Based on this work, future research could explore machine learning techniques to adjust constraints, simplifying the problem space and providing insights to aid reasoning, particularly for problems near the satisfiability boundary. Moreover, as quantum hardware advances, integrating machine learning, fidelity data, and solver-based methods shows great potential for developing more efficient qubit mapping techniques with higher scalability and fidelity.

SECTION: 6Conclusion

This work proposes a machine learning-based approach for accelerating optimal qubit mapping utilizing quantum circuit feature datasets. By leveraging an augmented and refined quantum circuit dataset, MLQM employs machine learning techniques to provide high-quality prior knowledge to the solver, significantly reducing the solver’s global search space, thereby accelerating the solving process. Moreover, MLQM adaptively adjusts the constraints in the solver, further narrowing the local search space. Consequently, MLQM eliminates the reliance on manually setting solver constraints based on experience, greatly enhancing the efficiency of qubit mapping.

Experimental results conducted on five quantum computer hardware architectures demonstrate the robust efficiency and stability of MLQM. Compared to OLSQ2, the state-of-the-art solver-based method, MLQM achieves an average speedup ratio of 1.79, with a maximum speed-up of 6.78. In terms of memory footprint, MLQM achieves an average reduction of 22%.
Compared with the leading heuristic algorithm SABRE, MLQM reduces the circuit depth by an average of 35.8% and the number of swap gates by an average of 46.2%, furthermore, the advantage of MLQM increases with the number of qubits in quantum circuits and coupling graphs, which demonstrates the excellent quality of the solutions provided by MLQM.

SECTION: Acknowledgements

This work was supported in part by the National Natural Science Foundation of China under Grant 62472072, the National Natural Science Foundation of China under Grant 62172075, and in part by Natural Science Foundation of Xinjiang Uygur Autonomous Region of China under Grant 2023D01A63.

SECTION: Appendix AExamples and Analysis of Regression Trees

This appendix presents two sets of results. The first set displays the tree structures of the models trained on circuit mapping for IBM Rochester and IBM Melbourne, as shown in Figures18and19, respectively. The second set illustrates the feature importance for the depth model and swap number model across all quantum computers, as depicted in Figures20and21. The feature importance is computed using the following formulas:

Here,denotes the target feature,are nodes whereis used as the splitting feature,denotes the mean squared error at node, andandare the left and right children of node. These data provide intriguing insights and lead to several significant conclusions.

Fig.20shows circuit depth is the most important feature on all quantum computer when predicting circuit depth after qubit mapping. When the coupling graph is a fully connected graph, qubit mapping does not introduce any additional swap gates, so the circuit depth after mapping remains the same as the original circuit depth. As the connectivity of the coupling graph decreases, the number of swap gates required by the circuit gradually increases, causing the mapped circuit depth to deviate from the original circuit depth. Sycamore and the 5x5 grid have the strongest connectivity, which explains why circuit depth is most critical for them.

According to Fig.21, circuit depth is the most important feature for Sycamore when predicting the swap number, due to Sycamore’s high connectivity and large physical qubit count, which bring Sycamore closer to the ideal scenario compared to other quantum computers. Moreover, across all quantum computers, circuit depth and circuit width consistently emerge as key features and demonstrating a complementary relationship. This underscores the importance of fundamental circuit characteristics in features. For IBM-Rochester and Aspen-4, circuit width and operation density are the most important features, with similar importance distributions, likely due to their lower connectivity. In these weaker-connected systems, increases in circuit width and operation density lead to larger circuit sizes and higher gate densities, which, in turn, require more swap operations. Overall, each feature shows strong importance on at least one quantum computer architecture, which is consistent with our considerations for feature selection.

SECTION: Appendix BMachine Learning Quantum Dataset

This study introduces MLQD, an open-source dataset designed for qubit mapping research. Utilizing the OLSQ2 mapping methodology[24], MLQD comprehensively maps five quantum computer architectures: Sycamore, IBM Rochester, IBM Melbourne, Rigetti Aspen-4, and a 5x5 architecture.

The dataset comprises two circuit categories sourced from QASMbench[28]and our proposed enhancement method, including circuits with exclusively two-qubit gates and hybrid circuits integrating single- and two-qubit gates. Each architecture contains a minimum of 700 samples. Each sample consists of three files: pre-mapping and post-mapping quantum circuits (.qasm), and a mapping process information file (.json) detailing circuit depth and swap numbers. Post-mapped circuits are stored in the respective sample’s /result folder.

MLQD facilitates research on quantum circuit mapping across diverse architectures and circuit characteristics. The dataset is continuously updating[31].

SECTION: References