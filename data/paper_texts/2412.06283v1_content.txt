SECTION: A lower bound on the state complexity of transforming two-way nondeterministic finite automata to unambiguous finite automata
This paper establishes a lower bound on the number of states
necessary in the worst case to simulate
an-state two-way nondeterministic finite automaton (2NFA)
by a one-way unambiguous finite automaton (UFA).
It is proved that for every,
there is a language recognized by an-state 2NFA
that requires a UFA with at least=states, wheredenotes Stirling’s numbers of the second kind.
This result is proved by estimating the rank of a certain matrix,
which is constructed for the universal language for-state 2NFAs,
and describes every possible behaviour of these automata during their computation.

Two-way finite automata, unambiguous finite automata, state complexity

SECTION: Introduction
A recurring question in finite automata theory
is the number of states in automata of one kind
needed to simulate an-state finite automaton of another kind.
It remains unknown whether
nondeterministic two-way finite automata (2NFA) withstates
can be simulated by deterministic two-way finite automata (2DFA) with polynomially many states,
and this question is known to be connected to theL vs. NLandL/poly vs. NLproblems in the complexity theory,
see Kapoutsisand Kapoutsis and Pighizzini.
Much progress has been made on the complexity of simulating two-way automata by one-way automata.
The possibility of such a transformation
is one of the earliest results of automata theory,
and the exact number of states sufficient and necessary to simulate 2NFA and 2DFA
by NFA and DFA
was later determined by Kapoutsis.
Other related results include the complexity of transforming two-way automata to one-way automata
recognizing the complement of the original language,
first investigated by Vardi, followed by Birget,
and later extended to alternating automata by Geffert and Okhotin.
Attention was given to transforming two-way automata to one-way
in the case of alphabets of limited size:
in the unary case, the complexity was studied by Chrobak,
Mereghetti and Pighizzini,
Geffert et al.and Kunc and Okhotin,
and later Geffert and Okhotinimproved the bounds for alphabets of subexponential size.
Recently, the complexity of transforming sweeping permutation automata to one-way permutation automata
was determined by Radionova and Okhotin.

Among the results of Kapoutsis,
let us note the precise complexity of transforming 2NFA to one-way DFA and NFA.
For an-state 2NFA,
the worst-case size of an equivalent DFA isstates,
whereas an equivalent NFA requiresstates
in the worst case.
Between these two perfectly conclusive results,
there is an open question involving an intermediate model between DFA and NFA:
theunambiguous finite automata(UFA),
which can use nondeterminism, yet are bound to accept each string in at most one computation
(as in the unambiguous complexity classes, such as UL and UP).

State complexity of UFA is an active research topic.
Leungstudied relative succinctness of NFA with different degrees of ambiguity,
and, in particular, proved
that transforming an-state UFA to a DFA requiresstates in the worst case.
For the case of a unary alphabet, Okhotinshowed
that the state complexity of transforming an-state UFA to DFA
is of the order,
which was recently sharpened toby F. Petrov.
A notable fact is that the complement of every-state UFA
can be recognized by a UFA with much fewer thanstates:
this was first proved by Jirásek Jr. et al.,
who demonstrated that at moststates are sufficient,
and soon thereafter Indzhev and Kieferimproved the upper bound to.
Lower bounds on the number of states necessary to represent the complement
have been researched as well:
in the case of a unary alphabet,
after an early lower boundgiven by Okhotin,
Raskindiscovered the state-of-the-art lower bound ofstates.
Later, Göös, Kiefer and Yuanused new methods based on communication complexity
to establish a higher lower bound ofstates
for a two-symbol alphabet.
Most recently, Czerwiński et al.carried out a detailed analysis of descriptional and computational complexity of unary UFA,
and, in particular,
showed that every-state unary UFA can be complemented using at moststates.

The complexity of transforming 2DFA to UFA was investigated recently by Petrov and Okhotin.
Since UFA is an intermediate model between NFA and DFA,
this complexity has to lie between the two bounds of Kapoutsis:, which is of the order,
and.
Both bounds were improved.
An improved upper bound ofstates
was obtained by a new 2DFA-to-UFA transformation,
which augments the NFA constructed by Kapoutsisto ensure the uniqueness of its accepting computation.
A lower bound ofstates
was proved by reducing the task to estimating the rank of a certain matrix.
The key element in the estimation is the rank of a particular submatrix,
which was earlier determined by Raz and Spieker.
Using it in the calculation leads to
an improved lower bound of the orderon the complexity of the 2DFA-to-UFA transformation.

The complexity of the 2NFA-to-UFA transformation has not been investigated up to date.
It has to lie between the lower bound
of the orderon the 2DFA to UFA transformation,
and Kapoutsis’ bound of the 2NFA to DFA transformation,
which is
of the order.
It is natural to ask what is the exact function in the case of the 2NFA to UFA transformation;
these known bounds are even farther apart than in the 2DFA-to-UFA case.
This gap is narrowed in this paper
by improving the lower bound to,
wheredenotes Stirling’s numbers of the second kind.
The new lower bound is asymptotically estimated as:
this is greater than the upper boundfor the transformation of 2DFA to UFA,
showing that these two functions are definitely distinct.
Additionally, the new lower bound
is much closer to the upper boundthan previously known.

SECTION: Definitions
The paper uses standard finite automata models,
two-way and one-way,
nondeterministic of the general form and unambiguously nondeterministic.

For a set, the setis defined as.

Anondeterministic finite automaton(NFA)
is a quintuple,
in which

is a finite alphabet;

is a finite set of states;

is the set of initial states;

the transition functiondefines possible next states
after reading a given symbol in a given state;

is the set of accepting states.

On an input string,
acomputationis a sequence of statessatisfyingandfor all.
It isacceptingif, furthermore,.
The set of strings, on which there is at least one accepting computation,
is denoted by.

An NFA is said to beunambiguous(UFA),
if there is at most one accepting computation on each string.

Two-way automata operate on strings delimited by a left and a right end-marker.

Atwo-way nondeterministic finite automaton(2NFA)
is a quintuple,
in which

is a finite alphabet,
which does not contain a left end-markerand a right end-marker;

is a finite set of states;

is the set of initial states;

the transition functiondefines possible transitions
after reading a given symbol in a given state;

is the set of accepting states,
effective at the right end-marker,
withfor all.

On an input string,
acomputationis a maximal sequence (which might be infinite) of pairs,
where in each-th pairis a state,is the position of the head, with.
In addition, the following conditions should be satisfied:,,
andfor all.
Here,and.

Such pairswithandare calledconfigurationsof the automaton.
The pairswithandare calledinitial configurations,
and a computation can start from any initial configuration.

The computation isacceptingif it is finite and its last pair
is, withand.
The set of strings, on which there is at least one accepting computation,
is denoted by.

SECTION: Lower bound
SECTION: The witness language and its 2NFA
Letbe a positive integer.
The goal is to construct a witness language,
which is recognized by a 2NFA usingstates,
but any equivalent UFA would require a substantial number of states.

Consider computations of a 2NFA on inputs of the form,
whereis aprefixandis asuffix.
Every accepting computation of the 2NFA on this input, if one exists,
starts with its head inside the prefix on the symbol,
and ends with its head inside the suffix on the symbol.
Then, such a computation must move its head from the prefix to the suffix at least once.
The sequence of moves that cross the boundary between the prefix and the suffix
is known as the crossing sequence.
If all moves in the crossing sequence are known and fixed,
then the existence of the entire accepting computation can be checked
by collecting some information
on the computations that fit inside the prefixand the suffix,
done separately for the prefix and for the suffix,
and then checking that the results can be matched together.

A deterministic one-way automaton (DFA) simulating a 2NFA on,
after reading the prefix,
must remember a fairly exhaustive set of computations of the 2NFA on the prefix,
because it cannot know in advance which of these computations later turn out to be necessary:
as shown by Kapoutsis, it requiresstates in the worst case.
In the same situation, a nondeterministic one-way automaton (NFA)
may remember less information
by using its nondeterminism to remember only what will later be needed;
for this simulation, Kapoutsis proved that as few asstates are always sufficient.
However, in the latter construction,
several sequences of guesses may lead to the acceptance,
which causes a problem to an unambiguous automaton (UFA) doing the same check.
Intuitively, it should not be able to use its nondeterminism to the full extent,
and will end up using substantially more states.

The proposed witness languageconsists of all strings of the form,
whereencodes a possible behaviour of an arbitrary-state 2NFA on some prefix,encodes its behaviour on some suffix,
and these two behaviours concatenated together allow at least one accepting computation.
This is in some sense a universal language for all-state 2NFAs,
and it is recognized by a fixed-state 2NFA.
This requires defining the encodings first,
and the first step is to understand what information needs to be included.

Consider a computation of a 2NFA on the input consisting of a prefixand a suffix.
Every configuration in this computation points at a particular symbol,
and hence the computation, as a sequence of configurations,
can be split into two kinds of segments:
those in which the 2NFA walks over the prefix,
and those in which it walks over the suffix.
All transitions made in a segment on the prefix depend only on,
and all transitions made in a segment on the suffix depend only on.

Every computation contains one or more segments on the prefix,
and the encoding for the prefix should describe
all such segments in all possible computations.
The first segment in a computation
begins in one of the starting states on the symbol,
and ends with the first crossing to the suffix;
all one has to remember about such segments is the set of states
in which the 2NFA can leave the prefix.
All other prefix segments are contained between two crossings
of the boundary between the prefix and the suffix,
one fromto, and the other fromback to.
It is sufficient to remember in which pairs of states the automaton can potentially make these two crossings
(the beginning and the end of a segment).

Similarly, every segment of an accepting computation on the suffix
is either a middle part contained between two crossings of the boundary,
or the final part that ends with acceptance.
For every possible middle part, it is sufficient to remember the states in which it crosses the boundary.
The final part is a computation that starts at the first symbol ofin some state
and accepts the string,
and all one has to remember is the set of states from which one can reach acceptance.

Denote.
Both for the prefix and for the suffix,
all information on the possible middle segments
can be encoded as a functionfromto:
for every state in the beginning of a segment (right after crossing the boundary),
it contains all possible resulting states in which the automaton can cross to the other side.
The initial segments (for a prefix), or the final segments (for a suffix)
are encoded as an extra subset of:
for a prefix, these are the states on the boundary
reachable from an initial configuration,
and for a suffix, this is a set of states that lead to acceptance.
Both sets are not empty, for otherwise no string could be accepted.

Letbe the set of states on the boundary reachable from the initial configuration
without leaving the prefix in the meantime.
Assuming that computations leaving the prefix exist at all (that is,is not empty),
letbe a state in which any of those computations first visits the last symbol of the prefix;
then, necessarily,, since each of the states incan then be reached from the statewithout leaving the prefix in the meantime.
Additionally, one can pretend that the states inare also reachable from every possible state,
that is,for every state;
after all, an ability to return to these states
would not let the automaton reach any states otherwise unreachable,
as they are reachable from the initial configuration anyway.
With this modification, there is no need to rememberat all,
because it equals the intersection of allfor all.
Hence, the encoding of computations on a prefix
can be simplified down to the following definition
(which is a slight modification of the construction given by Kapoutsis).

Aprefix tableis a function,
such that there exists at least one indexwithfor all.
Every suchis called astarting stateof.

Note that ifandare both starting states of,
thenand; hence,.

Denote asthe minimal integer that is a starting state of.
Then,equals the above set.

For a prefix table, itssizeis calculated as.

Two representations of prefix tables are frequently used in the following.
First, a prefix tablecan be considered as a matrix,
withif, andotherwise.
The other representation is by a bipartite directed graphon vertices,
withif and only if.

The representation of computations by a prefix table is illustrated in Figure.
Possible transitions of the underlying 2NFA are depicted with solid arrows,
and the additional arcs are depicted as dotted arrows.
The resulting graphis located on the right,
with the left part containing vertices of the form,
and the right part containing vertices of the form.
Starting states ofare encircled.

The information about all computations on a suffix
is stored in a suffix table,
which, for every state, represents all possible outcomes of the computations
beginning at the first symbol of a suffix in the state:
the outcomes include crossing to the prefix in a certain state,
as well as acceptance.
If acceptance is among the possible outcomes,
then one can pretend that all other outcomes are possible as well:
indeed, if a string can already be accepted,
then no additional transitions could make it otherwise.
Naturally, acceptance must be a possible outcome for at least one state,
otherwise the string cannot be accepted at all.

Asuffix tableis a function,
such thatfor some,
and for every index, if, then.

For a suffix table, denote asa bipartite directed graph
on the vertices,
withif and only if.
Also, define;
this is the set of indices leading to acceptance.

Computations on a suffix are represented by a suffix table
as illustrated in Figure.
Possible transitions of the underlying 2NFA are depicted with solid arrows,
and the arcs that were added are dotted.
The resulting graphis located at the left of the figure,
with its left part containing vertices of the form,
and the right part containing vertices of the form.

Letbe the alphabet of, the universal language for-state 2NFA.
This language is constructed as the language of a 2NFAwith the following properties:
the input alphabet is;
the set of states is;
the set of starting states is;
the set of accepting states is.
It uses the transition function, which is defined onas follows:

;

;

if, andotherwise.

If the input string is of a form,
for some prefix tableand suffix table,
then the automatonfirst memorizes the starting state at the first symbol, and then follows the transitions in prefix and suffix tables, checking whether the accepting state is reachable. An alternate representation of the accepting computation is a path in the graphthat starts inand ends infor some; the verticesrepresentbeing in stateon the second symbol, and the verticesrepresentbeing in stateon the third symbol.

Ifaccepts the string,
then a path can be constructed from an accepting computation as follows:
ifis on the symbolin state, add the vertexto the path;
ifis on the symbolin state, add the vertexto the path.
In both cases, the next transition corresponds to an arc from the current vertex in the graph
by definition of(has arcs to all verticeswith)
and(has arcs to all verticeswith).
The automatonfirst visits the second symbol in the state(dictated by the first symbol),
so the path starts in;
since the computation is accepting, the last vertex on the path iswith(the automaton cannot get to an end-marker otherwise)—which is equivalent to.

The converse statement has a similar proof: convert a path to a computation, and it will be accepting because at the end of the path it can leave the third symbol by moving to the right.
∎

The rest of this paper is concerned with proving a lower bound on the size of every UFA that recognizes the language. To the best of our knowledge, the only known method for proving such lower bounds is the following theorem.

Let, and let.

Letbe a UFA that recognizes the language.
Consider the matrixwith rows corresponding to the states ofand columns corresponding to the strings,
with valuesif(is accepted from state)
andotherwise.

Note that every row of the matrixis a sum
of some rows of the matrix; namely, of those that correspond to states
reachable fromafter reading(the sum in each cell cannot exceed 1, sinceis unambiguous).
Hence,cannot contain fewer thanrows,
and the number of states ofis at least.
∎

A stringcan be naturally divided
into a prefixthat depends only on a prefix table,
and a suffixthat depends only on a suffix table.
The set of all such prefixes shall be used asin Schmidt’s theorem,
and all such suffixes form the set.
Accordingly, the following matrix can be defined.

The matrixis a matrix
with rows indexed by prefix tables and columns indexed by suffix tables,
withif the automatonaccepts the string, andotherwise.

In order to obtain a lower bound on the size of a UFA recognizing the languagevia Schmidt’s theorem,
the rank of this matrix needs to be calculated.

SECTION: Rank-preserving matrix reduction
To calculate the rank of, we shall simplify it first.
This can be done by identifying some prefixes of the form,
for which the corresponding row of the matrix
is a linear combination of other rows.
Then, those prefix tables can be excluded
without affecting the rank of the resulting matrix.

For a bipartite directed graphtogether with a vertexand a set, define the function, which is equal toif there is a path inthat starts inand ends in, andotherwise. Note that, by Lemma, the automatonaccepts the stringif and only if.

The redundancy of some rows in the matrixis ultimately inferred from the following lemma.

Obviously, if, then all four values of the function are equal to, and the equality holds. Also, if, then all four values are equal to, and the lemma is proved as well.

Suppose now, thatand, but. Then, the latter sum is equal toor; therefore,andare either both equal toor both equal to.

Consider those two cases.

andare both equal to 0.

Since, there is a path fromtoin the graph.
Letbe a simple path between them.
This path does not exist in graphsand(otherwise,would be equal to 1), therefore, both edgesandare in.

Ifgoes beforein,
then the whole part of the path between them can be replaced with the edge.
Similarly, ifcomes first, then this part can be replaced with the edge.
In both cases,, which contradicts the assumption that.

The case ofgoing beforeinis illustrated in Figure(a),
in which the dotted lines represent the path,
and the path fromtoinis obtained by replacing the longer route fromtowith a single arc.

andare both equal to 1.

Letbe a simple path fromtoin the graph,
and letbe a simple path between them in. Note thatand, since. Then, the paths can be written asand. However, the pathcontains neithernor, and is a path fromto; hence,, which leads to a contradiction.

Figure(b) illustrates this case.

∎

The same equality can be stated in terms of prefix tables. However, it requires proving that prefix tables augmented with one or two extra values remain valid prefix tables.

First we shall prove that functions,andare all prefix tables.
They all are defined on, all their values are in,
and all values are non-empty since they contain the corresponding value of.
Then, it is enough to show that each of those functions has a starting state.
It is claimed that a starting stateofqualifies,
meaning that for all, the conditions,andhold true.

To prove this, it is enough to show that neithernorare the starting states of;
indeed, if they are not, then,
same forand.
Suppose then, thatis a starting state of.
Then,.
However,; then,as well,
which leads to a contradiction since.
The proof thatis not a starting state is similar.
This confirms that,andare prefix tables.

We would also want to prove that the minimal starting state
is the same for all four prefix tables;
that is,.
The proof is given for the case of.
First, note that, because such a containment holds for every argument.
Next,, sinceis a starting state of.
The latter setequals, becauseis not equal toor to,
and those are the only two indices for which the values of the four prefix tables differ.
And it is known thatfor all, becauseis a starting state of.
This chain of inclusions implies thatfor all,
meaning thatis a starting state of.
Now, bothandare starting states of bothand,
and hence,and.
This proves that.

It remains to show thatfor every suffix table.
Let.
Defineand;
then,,and.

Then, by Lemma,.
By Lemma, each of those four values
can be represented in terms of the matrix:
for instance,.
Since,
this transformation is valid for all four values.
The desired result then follows.
∎

Then, for anythat satisfies the conditions
in Lemma,
the corresponding rowinis a linear combinationof rows for prefix tables of greater size,
and can therefore be removed without affecting the rank.
By iterating over all prefix tablesin order of increasing size,
all remaining rows would correspond to prefix tables
for which the condition in Lemmadoes not hold.
The remaining prefix tables are calledordered(the meaning of this term will be revealed
in the next Section).

A prefix tableis calledorderedif there are no such elementsandthat, but.

A reduced matrix can then be defined.

The matrixis a matrix with rows indexed by ordered prefix tables and columns indexed by suffix tables, withif the automatonaccepts the string, andotherwise.

In particular,for any ordered prefix tableand any suffix table.

The matrixforis illustrated in Figure.
The rows are labeled by graphs corresponding to ordered prefix tables,
with circled vertices corresponding to.
The columns are labeled by graphs corresponding to suffix tables,
with circled vertices representing the ones that are in.
Filled cells are those containing 1, and empty cells contain zeroes.

Construct a sequence of matricesas follows:is a submatrix ofobtained by removing a row corresponding to a non-ordered prefix tablewith minimal. Since there is only a finite number of rows in, this process will eventually stop; the resulting matrix will have rows corresponding to exactly all ordered prefix tables, so it is equal to.

It is enough to prove thatfor all; then all ranks of the matrices in the sequence are equal, and in particular,.

Letbe the (non-ordered) prefix table corresponding to a row that is present inand absent in. Sinceis not ordered, there exist indicesandsuch that, but. Then, by Lemma,for any suffix table. Hence,as rows.

All of those rows are present in, since,andare all greater than, so the corresponding rows were not removed before the removal of. Therefore, the row corresponding to a prefix tablein the matrixcan be represented as a linear combination of other rows in the same matrix. Hence, the rank of the matrix does not change upon deletion of such row, and.
∎

SECTION: Ordered prefix tables
There is a nicer characterization of a prefix table being ordered, which explain the choice of a term used.

Assumeis not ordered, but for everyeitheror.
Then, there are elementsandthat, but.
Therefore,, sincecontains, anddoes not.
Similarly,, sincecontains, butdoes not.
However, eitheror, which leads to a contradiction.

Conversely, assume thatis ordered,
but there are elementssuch thatand.
Obviously,, otherwise.
Letand.
Letbe any element of the set,
which is not empty since.
Let; it is not empty because.
Then,,
but,
which contradicts the table’s being ordered.
∎

It follows that the values of an ordered prefix tablecan be ordered:.

This chain of inclusions can contain identical sets, so an additional sequence is defined.
For an ordered prefix table, letbe a sequence of unique sets in this ordering. Note that the setis always present, even if there is no indexsuch that; this is relevant for the definition below.

Therankof an ordered prefix table, denoted, is equal to the number of unique sets.

In the terms of a sequenceabove, the rank ofis equal to.

The rank ofis also equal to the rank of a matrix, whereis a matrix in which every element is equal to. In the matrix, the element on the intersection of rowand columnis equal toif, andotherwise.

Let.
Consider the rows of a matrix. The intersection of a rowand a columncontainsif, andotherwise; therefore, the entire row is uniquely determined by the value of. Moreover, if, the entire row contains only zeroes. Therefore, there are onlypossible non-zero values of rows in the matrix, corresponding tobeingrespectively. Hence,.

The converse is proved by finding a full-ranksubmatrix of.
Letforbe some indices such that.
Letbe some elements offor;
such indices always exist, sinceis non-empty and.

It is claimed thatif and only if.
Indeed,if and only ifby definition,
and the latter holds if and only if,
becauseandby the choice of.
Thus, the submatrix offormed by rowsand columnsis a upper-triangular matrix
with all 1on the main diagonal and above.
Hence, it is full-rank,
and the rank of the entire matrixis at least.

Sinceand,
the valuesandare equal.
∎

For an ordered prefix tableand an index,
theprefix layerofin, denoted by,
is defined as the indexsuch that.

A prefix layer is a characterization of how powerful the given state is if obtained on a prefix.
All states on the same prefix layer lead to the same states on a suffix,
and a state on a higher prefix layer leads to a strictly larger set of states
than any state on a lower prefix layer.

Note that the prefix layer of a starting stateis equal to 0,
and the prefix layer of everyis bounded by the rank of the prefix table
().
All layers fromup tomust be non-empty,
whereas layermay be empty
(it is empty ifis not in the image of).

For an ordered prefix tableand an index,
thesuffix layerofin, denoted by,
is defined as the minimal indexsuch that.

In terms of the simulated automaton,
the suffix layer of a state indicates
how powerful a prefix state must be
to be able to get from it to this state on the suffix.

Prefix layers and suffix layers together form a structure of a given prefix table.
This structure is illustrated in Figure.

SECTION: Linear independence of rows of the matrix
Rows ofcorrespond to ordered prefix tables,
and are actually linearly independent.
The proof of this relies on finding a certain difference
between any two distinct ordered prefix tables.
This notion of difference is expressed in the definitions below.

Letbe an ordered prefix table.
For another ordered prefix tableand a layer(,
the prefix tableis said tobreak throughlayerofif there are such indicesthat,and.
The set of all layers thatbreaks through for a givenis denoted by.

This notion is illustrated in Figure(a).

In other words,breaks through layerif it is stronger thanwith regard to this layer:
starting in all prefix states of all layers up toof,
one can get to a suffix state on a higher layer by following the arrows,
regardless of the suffix table used.

The next lemma shows
that a breakthrough is guaranteed ifhas at least as many arcs asand is different from.

Suppose thatis empty.
Then, for everywith,
all elementshave,
and thus.
In particular,.
However, their sumis at leastby assumption;
therefore, for every, the equalityholds.
Sinceand, it follows that.
This is true for every, so, which is a contradiction.
∎

Letbe an ordered prefix table.
For an ordered prefix tableand a layer(,
the tableis said todrop downfrom layerofif for everywithand for all, the suffix layeris strictly less than.

In other words,drops down from the layerif it is weaker thanwith regard to this layer:
starting in all prefix states of all layers up toof,
and following the arrows provided by,
one cannot get to a suffix state not only in layers beyond the-th,
but even in the-th layer itself.
This is illustrated in Figure(b).

Note that a prefix table does not break through or drop down from its own layers, due to how both definitions work.

Suppose this is not the case,
and there is a linear combination,
whereis a vector of all zeroes,
the sum is over all ordered prefix tables,
and not allare equal to.
Among all ordered prefix tableswith,
letbe one of those with minimal,
that is, with the least number of arcs defined.

The general plan is to show that for eachwithand,
the difference betweenandmanifests itself in the linear combination,
so that there is a column that does not come down to 0 in the total sum.
By Lemma,
every suchbreaks through some layer ofsimply be the virtue of having at least as many arcs and being different;
whereasdoes not break through its own layers.

The first goal is to construct, for each ordered prefix table,
a corresponding suffix table,
such that,
in the graph formed byandtogether,
there is a path that passes through all the layers ofand reaches acceptance,
whereas in the graph formed byandthere is no such path.
Thisdepends only on the set of breakthroughsfor,
and whatdoes is to stage additional breakthroughs in all remaining layers.

Let.
For each subset,
construct a suffix tableas follows:
for every indexwith,
the setcontains all nodeswith,
that is, no breakthroughs are attempted;
and forwith,
the setconsists of all nodeswith,
thus “breaking through” the next layer.
The elementis considered to be on the prefix layerfor the purposes of this definition.
More formally,

The desired properties of the suffix tablesare established in the three claims below.
The first claim is that the setof indices ofleading to acceptance
is exactly the top-th suffix layer of,
and also its-th suffix layer, provided thatstages a breakthrough at layer.
No elements from any lower layers may be in.

The setis defined as a set of indicessuch thatcontains,
which only happens in the definition above in the third case.

If,
then suchwill always satisfy one of the first two cases, socannot be in.
If,
thenis always defined as, and thus.
Finally, if,
thenwill use the first case in the definition ifand the third case otherwise.

Thus, if, thenis equal to the set of indicesfor whichis at least.
Since,
this is equivalent tobeing exactly,
and hence, as claimed.
In the case that,
the setcontains both indiceswithand with, and nothing else;
this condition can be simplified as.
∎

The second claim is that if an ordered prefix table
drops down from any layer of,
then this prefix table does not affect the linear combination
on the columns corresponding to, for various.

By Lemma,if and only if
there is no path inthat starts inand ends infor some.

It can be shown that any path fromnever goes beyond prefix layeron the left
and never reaches the-th layer or beyond on the right;
formally,
it only visits verticeswithand verticeswith.
The proof is by induction on the length of the path;
the base case is a path of length 0, which only visits a single prefix vertex,
and this vertex is on layer 0, so the statement is correct.

For the induction step, consider the second-to-last vertex on a path.
If it is, then by inductive assumption.
Letbe the last vertex on the path.
Then,,
and sincedrops down from the layer, the last vertex has.

Similarly, if the last two vertices on the path areand,
thenby inductive assumption,
and.
Then, by the definition of,
the prefix layer ofis,
as claimed.

Now, by Claim,
the setcan only contain indiceswith.
On the other hand, every path inthat starts incan only reach verticeswith.
Therefore, a path fromcannot visitfor any,
and thus.
∎

The last claim is in some sense complementary to Claim:
it says that if an ordered prefix tabledoes not drop down from any layer of,
then it affects the linear combination
on the columns corresponding to, for various,
and the elementsdepend only on the setof breakthroughs of,
and not onitself.

Note that bothandare subsets of.

$\Rightarrow$⃝
Suppose that there is an indexsuch thatand, but.
Then, by Lemma,
there exists a path inthat starts inand ends infor some.

It will be shown that every path that begins innever goes beyond layerboth on the left and on the right:
that is, it
only visits verticeswithand verticeswith.
The proof uses induction on the path length;
the base case is a path of length 0,
which visits a single prefix vertex of layer 0.

For the induction step, consider the last two vertices on a path.
If the second-to-last vertex is,
then by inductive assumption.
The last vertexon the path satisfies,
and sincedoes not break through the-th layer,.
Similarly, if the second-to-last vertex is,
then by inductive assumption,
and since, then for allthe layerby definition of,
including the last vertex on the path.

By Claim,
the setcan only contain indiceswith.
Since, a path fromcan visitwithonly if.
But then,
and thereforecontains only indiceswith,
so the path does not exist in this case as well.

$\Leftarrow$⃝
Now, suppose that the union of setsandis,
but.
Then, according to Lemma,
there in no path in the graphthat starts inand ends in any vertexwith.

Let,
and let.
Let,
and let.
Since no accepting vertices are reachable,
the setdoes not contain any indices from.
By Claim, this implies that,
and if, then furthermore.

It is claimed that, which is proved as the following two inequalities.

This inequality is inferred from the definition of.
Indeed, letbe the index with.
Then, the vertexhas arcs
leading into all verticeswith.
Hence, all those vertices are reachable.
Moreover, sinceand the rank ofis,
there is at least one indexwith,
as there is at least onewithby definition of.
Accordingly,.

To see that the inequalityis also true,
first note that.
This follows from the definition ofas follows.
If there is a pathin the graphleading to some vertex,
then there are paths to all verticeswith,
obtained by replacing the last vertex on the path;
those paths are valid by the definition of.

Now, the tabledoes not drop down from the layerof,
that is, there are indicesandsuch that,, and.
Thisis in,
and the latter set, as noted earlier, equals.
Then, the vertexis reachable, and it has an arc leading to.
Therefore,is also reachable, and.
Then,.

Asis both no less and no greater than, those two values are equal:.
Sinceby the assumption,
and,
this implies that eitheror.
Consider these two cases.

If, then the above argument forcan be strengthened to show that.
Indeed, as mentioned above,implies that,
that is,,
and then, by the definition of,
there are arcs fromto all verticeswith.
And since, there is an indexwith.

If, then the argument foris extended to prove that.
The condition thatbreaks through the layerofis that there exist indicesandsatisfying,, and.
As in the previous proof,is reachable via,
and.
This time,.

Altogether, eitheror,
and asandwere proved to be equal,
both cases result in a contradiction.
This proves that, as claimed.
∎

Due to linear dependence, for every,

For everythat drops down from some layer of,
by Claim,
the value ofisfor all,
and so the terms for all suchcan be excluded from the sum.

All remainingdo not drop down from any layers,
hence by Claim,
the value ofis equal toif and only if,
and otherwise it is.
Thus, it has been proved that

Next, letfor ordered prefix tableswith the same set of breakthroughs be grouped together.
For every set of breakthroughs,
letbe the sum offor allwithwhich do not drop down from any layers of.
Then the above sum is expressed as

The left-hand side is equivalently expressed as,
wherecan be any subset of.
Therefore, for every set,
the following equality holds.

The following representing ofby the inclusion-exclusion principle
contains the above sum as a subexpression,
and hence the latter equality implies that everyis zero.

For,
letbe the total coefficient ofin the above sum, so that it is represented as.

If, then, sinceoccurs only once with coefficient 1
(that is, forin the first sum, andin the second sum).

Now let.
Then there exists an indexsuch that, but.
Let us split all possiblewithinto pairs
which differ by the inclusion of(so, if, it is paired with).
Each pair producesonce with the coefficient,
and once with the coefficient, which cancel out.
Therefore, in this case,.

Hence,,
as claimed.
Furthermore, by the above proof, every inner sumis zero,
and therefore, the whole sum is equal to.
∎

On the other hand,formust be non-zero
by another line of reasoning.

By definition,is a sum ofsuch that,
anddoes not drop down from any layers of.
Note thatsatisfies both conditions due to how layers are defined,
and is therefore included in the sum.

Suppose now that there is some otherwithwhich is included in the sum.
Due to the choice of, the sizeis at least.
Then, by Lemma,
the setis not empty, which leads to a contradiction.

This confirms that.
Since the coefficientis non-zero by the choice of,
it follows that.
∎

Now the value ofcannot be simultaneously zero and non-zero.
Therefore, there is no non-trivial linear combination
of the form,
and the rows ofare linearly independent.
This completes the proof of Theorem.
∎

This theorem gives a way to calculate the rank of the original matrix.

By Theorem,.
By Theorem, the rows ofare linearly independent,
therefore, the rank ofis equal to the number of rows in.
By definition, the rows ofare indexed by ordered prefix tables on.
∎

SECTION: Rank calculation
Corollaryallows the rank of the original matrix
to be calculated using combinatorial methods.
The question is, how many ordered prefix tables onare there for a given?

Letbe an ordered prefix table.
Then, by definition of a prefix layer,for every.
Hence, theprefix layer functionmapping eachto its prefix layer,
and the setsof prefix layer contents, for all,
together uniquely determine.

However, there are some limitations on both objects.
The condition on the prefix layer function
is that every layer (except for the optional last one) actually exists,
that is, occurs in the image of.
This condition is expressed in the following abstract definition of a prefix layer function
that is independent of.

Letbe a non-negative integer.
A functionis called avalid prefix layer functionof rank,
if for every valuethere issuch that.
Letbe the number of valid prefix layer functions of rank.

The conditions on the setsis that they are non-empty and strictly nested within each other.

Letbe a non-negative integer.
A sequence of setsis called avalid nested set sequenceof rank, ifis non-empty.
Letbe the number of valid nested set sequences of rank.

It will now be proved that pairs of a valid prefix layer function and a valid nested set sequence
are in one-to-one correspondence with ordered prefix tables.
First, one can naturally extract such a pair from every ordered prefix table.

For every, the valueis the number of an actual layer. Therefore,, andmapsto.

For every, there is an indexsuch that(by definition of). Then,. Hence,is a valid prefix layer function of rank.

By definition,. Each of those is either equal to some, which is non-empty by the definition; or is equal to, which is also non-empty. In particular,is non-empty. Therefore,is a valid nested set sequence of rank.
∎

Next, it is proved that
this representation of an ordered prefix table into a valid prefix layer function
and a valid nested set sequence uniquely determines it.

By definition of a prefix layer,andfor all. Then,for all. Hence,.
∎

Finally, every possible pair of those objects has a matching ordered prefix table.

Sinceis a valid nested set sequence, the setis non-empty.
Sincefor all, the same is true for all sets.
Sincefor all, all setsare
nonempty subsets of,
sois indeed a function fromto.

Sinceis a valid prefix function, there is an indexsuch that(if, it is the only possible value;
if, this follows from the definition).
Then,, and for every,is a subset of.
Therefore,is a starting state, andsatisfies the conditions on a prefix table.

Letbe two indices, and suppose that.
Then,.
Similarly, if, then.
Hence, for any two indices, eitheror.
Therefore, by Lemma,is an ordered prefix table.

Sinceis a valid prefix function, for everythere is an indexsuch that. Then,, and the set of all values ofincludes all(except, maybe,). By definition of, the set of all values ofis included in the set of all. Therefore, the sequenceis obtained by ordering the set(sinceis always included in the resulting sequence), and all elements of this set are distinct. Hence,. In particular,.

Additionally, for any, the value, therefore. Since this is true for any, the functions coincide:.
∎

This bijection provides the following way to calculate the number of ordered prefix tables of certain rank.

By Lemmata,and,
there is a bijection between ordered prefix tables of rankand pairs consisting of a valid prefix layer function of rankand a valid nested set sequence of rank.
Therefore, the sizes of sets of those objects are equal.
In addition, the number of pairs is equal
to the product of numbers of possible choices for each object in a pair.
Hence, the lemma is proved.
∎

Both limitations on valid objects can be expressed in terms of partitions.
The prefix layer function of rankcan be seen as an ordered partition ofintonon-empty parts and one possibly empty part,
all of them pairwise disjoint, one for each layer number.
The nested set sequence of rankcan be described
as an ordered partition ofintopairwise disjoint non-empty sets:together withsets of differences.
This provides a way to expressandin terms of partitions.

Letbe integers.
AStirling number of the second kind, denoted,
is defined as the number of ways to partition the setintonon-empty pairwise disjoint parts.

It is well-known that the number of surjections from an-element set to a-element set
is exactly.

The proof is by establishing a bijection between
valid prefix layer functions of rankand surjective functionsfromtosuch that,
and then determining the number of such functions.

Letbe a valid prefix layer function of rank,
that is, for every valuethere is an argumentwith.
Consider a functiondefined asfor, and.
Since all values betweenandbelong to the image of,
this function is surjective,
and it mapsto.
Furthermore, different valid prefix layer functionsproduce different.
Therefore, there are at least as many different surjective functions withas there are valid prefix layer functions of rank.

To see that every surjective functionsuch thatcan be expressed in the form offor some valid prefix layer functionof rank,
define the functionas.
It is enough to show thatis a valid prefix layer function of rank;
then,will hold true.
Sinceis surjective, for every,
there is an argumentsuch that.
Herecannot be, because, whereas.
Then,, and accordingly,.
This establishes the desired bijection.

It remains to determine the number of surjective functions fromtowith.
For each, letthe number of surjective functions fromtowith.
By the symmetry,,
and since the total number of surjective functions is,
the desired numberis.
∎

Letbe the set of all valid nested set sequences onof rank, and letbe the set of ordered partitions ofintoparts. Note that, since an ordered partition is specified by a partition and an order of its blocks. Therefore, it is enough to show that.

Define a functionas follows: for the valid nested set sequence, consisting of sets, define an ordered partition, consisting of sets, asandfor. Note that sinceis a valid nested set sequence, bothand all of differencesare non-empty. Additionally, sinceare nested into each other, the setsdo not intersect; also, since, the union of allis equal toas well. Therefore,is an ordered partition ofintoparts. Define.

Now, define an inverse functionas follows: for the ordered partitionofinto sets, define. Sinceare all non-empty, the setsare strictly nested into one another; also,is non-empty and; therefore, the sequence, composed of sets, is a valid nested set sequence. Define.

The equalityfollows from the fact that; the equalityfollows from the fact that. Therefore,andare both bijections. Hence,, which means that.
∎

Those results can be combined into the final one.

An ordered prefix table oncan have a rank ranging fromto, inclusive (since, for an ordered prefix table, the size of a final set, butdue to being strictly contained into one another). By Lemma, for each rank, there areordered prefix tables of this rank. Therefore, there areordered prefix tables onin total.

By Lemma, the valueis equal to. By Lemma, the value. Substituting them into the formula above yields the desired result.
∎

By Theoremfor a 2NFAand its language, every UFA recognizing the same language has at leaststates. By Corollary, the rank ofis equal to the number of ordered prefix tables on. Finally, by Theorem, there areordered prefix tables on. Therefore, every UFA recognizing the languagerequires at leaststates.
∎

SECTION: Asymptotics of the lower bound
An asymptotic bound on this sum is obtained by estimating a single term, with. Then,.

The Stirling numbers of the second kind in this term can be calculated precisely.
There is only one partition ofintoparts, since then every part consists of a single element (hence,).
Also, there arepartitions ofintoparts, since all parts except one must consist of a single element, and there areways to choose the remaining two-element part.
Therefore,.

By Stirling’s approximation,. Hence,.
∎

How does it fare compared to the other bounds on 2NFA transformation?
The transformation of 2UFA into UFA, which provies a natural lower bound for a 2NFAUFA transformation,
has a proven lower bound ofstates, which grows merely exponentially.
The 2NFA-to-DFA transformation (an upper bound), however,
requiresstates,
which is of the order of.
The comparison between those three bounds is presented in the Table.

SECTION: Optimality of the lower bound
There is a companion result that it is not possible to achieve a better lower bound via Schmidt’s theorem by choosing another 2NFA and different pairs of strings.

In order to prove it, we will first introduce terminology
similar to that used in Section,
and establish results showing that the same conditions must be satisfied.

Letbe the set of states of the 2NFA. Letbe the set of starting states of.

In order to analyze the computations ofon all concatenations, we will consider all possible computations on prefixesand on suffixes. The set of possible computations can be represented with prefix and suffix tables as follows.

For each prefixof a possible input string, the computations ofon the prefixcan be represented by a function similar to a prefix table.

Letbe a string. Define the functionrepresenting the computations ofon the inputas follows.
Letbe the set of indicessuch that there is a computation ofon the stringthat starts in a state fromat the first symbol of, and ends up moving to the right beyond the last symbol ofinto the state.
In addition, for every, letbe the set of indicessuch that there is a computation ofon the stringthat starts in a stateon the last symbol of, and ends up moving to the right beyond the last symbol ofinto the state.
Then, for every, define.

In essence, the functionis a transition function on the string, but the transitions to states inare added to every possible state. Since the states fromare reachable from start anyway, this should not change any acceptance status.

The functionbecomes a prefix table if a simple condition onis satisfied.

Sinceis not empty, and for everythe valuecontains, all the values ofare non-empty.
Therefore,is a function fromto.

To prove thatis a prefix table, it remains to show that there is a starting state of: that is, that there is an indexsuch thatfor every.

For that, letbe the set of indicessuch that there is a computation ofon the stringthat starts in a state fromat the first symbol of, and first enters the last symbol ofin the state. Note that, since any computation from the definition ofthat ends in a statecan be extended by a computation from the definition ofto obtain a computation from the definition of. Similarly,, as any computation from the definition ofcan be split into two computations: one from the definiton ofuntil the first visit of the last symbol of, and the remainder from the definition of somefor. Hence,.

Sinceis not empty, and, the setis not empty as well.
Letbe any index in.
Thenby the definition of.
Hence, this indexis a starting state,
becausefor every.

Since the values of a prefix table for all starting states are equal,for each starting stateof.
∎

If those conditions are not satisfied, then the corresponding row of the matrixcontains only zeroes, as is shown by the following lemma.

Suppose the converse is true, and there is a stringsuch that. Consider an accepting computationofon string. By definition, the automatoncan accept the string only while reading the symbol. Therefore, this accepting computation leaves the stringat some point. Letbe the state in which the automaton following the computationends up after moving beyond the stringfor the first time.

Letbe the computation obtained fromby removing all steps after leaving the stringfor the first time.
Then, the computationcan be seen as a computation on the stringthat starts in a state fromat the first symbol of, and ends up moving to the right beyond the last symbol ofinto the state.
Hence, by definition of, the indexis in, which leads to a contradiction withbeing empty.
∎

The same results can be formulated for suffixes as well.
For each suffixof a possible input string, the computations ofon the suffixcan be represented by a function similar to a suffix table.

Letbe the set of accepting states of.

Letbe a string. Define the functionrepresenting the computations ofon the inputas follows.
Letbe the set of indicessuch that there is a computation ofon the stringthat starts in a stateat the first symbol of, and ends up in a state fromon the last symbol of.
In addition, for every, letbe the set of indicessuch that there exists a computation ofon the stringthat starts in a stateat the first symbol of, and ends up moving to the left beyond the first symbol ofinto the state.
Then, for every, defineif, andotherwise.

In essence, the functionis a transition function on the string,
but with the addition of all possible transitions from statesfor.
Since the automaton in one of those states at the first symbol ofeventually accepts anyway,
this modification should not change the acceptance status of any strings.

Note thatis already a function fromto.
As per Definition,
it has to be checked that the value ofon some index contains,
and if it contains, it must contain everything else.

Letbe some index in; it exists, sinceis not empty. Then,by definition of, and therefore,. Hence, there is an indexsuch that.

Letbe any index with.
Then,, because otherwise,
which is a subset ofand does not contain. Hence,by definition of.
∎

By definition,is the set of indicessuch that.
By definition of, the setis the set of indicessuch that– that is, such that.
Therefore,.
∎

Similarly, if this condition does not hold, the corresponding column is empty.

Suppose the converse is true, and there is a stringsuch that. Consider an accepting computationofon string. By definition, the automatoncan accept the string only while reading the symbol. Therefore, this accepting computation enters the stringat some point. Letbe the state in which the automaton following the computationends up after moving into the stringfor the last time.

Letbe the computation obtained fromby removing all steps before entering the stringfor the last time.
Then, the computationcan be seen as a computation on the stringthat starts in a stateat the first symbol ofand ends up in a state fromon the last symbol of. Hence, by definition of, the indexshould be in the set, which leads to a contradiction withbeing empty.
∎

Therefore, a reduced matrix can be defined. Letbe a subset ofconsisting of all stringssuch thatis not empty. Letbe a subset ofconsisting of all stringssuch thatis not empty. Letbe a submatrix of, with rows indexed by stringsand columns indexed by strings, with. This is equivalent toif, andotherwise.

The matrixcan be obtained from the matrixby deleting rows corresponding toand columns corresponding to. By Lemmataandrespectively, those rows and columns consist of all zeroes.

The removal of all-zero rows or columns does not reduce the rank of the matrix, therefore the ranks ofandare equal.
∎

Thanks to this lemma, it is enough to prove the bound on the rank of the matrix.

It turns out that, for stringsand,
knowing the pair of functionsandis sufficient to determine
whether the concatenationis accepted by the automaton.
To be precise, its acceptance is determined
by the existence of a path in the graph.
The following lemma states that ifis accepted, then the graph contains a certain path.

Letbe an accepting computation ofon input. Such computation exists, since.

Since the computationstarts at the left end-marker, and finishes at the right end-marker due to its acceptance, the computationcrosses the border betweenandat least once, and an odd number of times in total. Hence, the computationcan be split into partswhereis a computation contained inside the string, and leaves it with the last move;is a computation contained inside the string, and leaves it with the last move (except for, which accepts); the last moves of each part are border crossings betweenand. Letforbe the index of the last state in the computation, into which it moves when it leaves the string; letforbe defined the same for.

Note that, by definition,, sinceis a computation that starts in a valid starting state forand leaves the stringinto the state. Accordingly,, sinceis a computation that starts in a stateat the first symbol ofand accepts without leaving the string.

Define.
To finish the proof, it is enough to show that the graphcontains the arcs fromto,
and fromto, for all.
Indeed, in this case the sequenceis a path inthat starts inand ends infor some, sinceandby Lemma.

For all, the existence of the arcs follows directly from the definitions ofand, since(the corresponding computation is), and(the corresponding computation is). Finally,, and so the graphcontains an arc fromtoas well.
∎

Conversely, if such a path is in the graph, then the concatenationis accepted.

Sinceis a bipartite graph with partsand, any path in it alternates between those two parts.
Letbe the shortest path infromtowith; let the vertices ofbe, whereand. Note thatandby the definition of graphsandrespectively. Also note that; sinceby Lemma, this means that.

By Lemma, the value of the functionis equal to.
Sinceby definition of the graph, then.
Additionally, sinceis the shortest such path,
for allthe indexcannot be in,
otherwise there is an arc fromtoin the graph,
and the path can be shortened. Hence, for,instead.
Accordingly, for all, the indexis not in, otherwise a shorter path can be constructed by removing everything inafter the vertex. Therefore, for, the value, and thus.

Letbe a computation ofon the stringthat starts in a state fromon a symbol, and ends up moving out of the stringinto the state; such computation exists, since. Letforbe a computation ofon the stringthat starts in a stateon the last symbol of, and ends moving out of the stringinto the state; such computation exists, since.

Letforbe a computation ofon the stringthat starts in a stateat the first symbol of, and ends up moving out of the stringinto the state; such computation exists, since. Letbe a a computation ofon the stringthat starts in a stateat the first symbol of, and ends up accepting the string; since, such computation exists.

Then, the computationis an accepting computation ofon the string, and therefore,.
∎

Lemmata–imply a connection between the matricesand(defined in the beginning of Section),
which is expressed in the following lemma.

Since, the setis not empty. Since, the setis also not empty. Therefore, by Lemma,is a prefix table; also, by Lemma,is a suffix table.

By definition,if, and 0 otherwise. By definition,if the graphhas a path that starts inand ends infor some, andotherwise. By Lemmataand, those two conditions are equivalent.
∎

However, the matrixneed not be a submatrix of,
as there might be duplicate rows corresponding to stringswith, or duplucate columns corresponding to stringswith.

Therefore, yet another reduced matrix is defined, which will be denoted. Letbe the set of all prefix tablesfor, and letbe the set of all suffix tablesfor. Then, definefor all,. This definition is correct, as by Lemmathe value ofdepends solely on the functionsand.

For a prefix table, letbe some string which has this prefix table:.
Letbe the set of all representatives, for different.
Similarly, for a suffix table, letbe some string which has this suffix table:. Letbe the set of all.

Then, the matrixcan be obtained fromby removing rows corresponding toand columns corresponding to.
Each of those rows and columns removed is duplicate of one in the reduced matrix:
by Lemma,
the row corresponding tocoincides with the row for,
and the column corresponding tocoincides with the column for.

Since the removal of duplicate rows or columns does not reduce the rank of the matrix, the ranks ofandare equal.
∎

By Lemma, for alland,. Hence, the matrixis a submatrix of.
∎

Those results together represent the proof of the theorem.

By Lemma,.
By Lemma,.
By Lemma,.
By Corollary, the rank ofis equal to the number of ordered prefix tables on.
Finally, by Theorem, there areordered prefix tables on.

Therefore,.
∎

SECTION: Conclusion
The lower bound on the state complexity of transforming 2NFA to UFA
established in this paper is of the order,
which is well above the upper bound ofon the 2UFA-to-UFA transformation,
established in the previous paper by the authors.
This result shows that the tradeoff functions for the 2NFA-to-UFA
and 2UFA-to-UFA transformations must be different.
However, the new lower bound is still far from the current upper bound,
derived from 2NFA-to-DFA transformation, which is of the order.
The lower bound derived in this paper
is compared to the known bounds on the 2NFA-to-UFA tradeoff
in Table.

All bounds presented in the table
rely on using an alphabet of exponential size in the number of states;
the bounds might be different in the case of alphabets of subexponential size,
as is known to be the case for 2DFA-to-DFA and 2DFA-to-NFA transformations.

It would be interesting to determine the 2NFA-to-UFA tradeoff precisely.
However, as shown in Theorem,
it is not possible to obtain a greater lower bound
by the means of Schmidt’s theorem alone.
Hence, new methods would be needed for any further improvements to the lower bound.

An improvement of the existing upper bound,
if possible at all, would require a completely new construction
showcasing the difference between UFAs and DFAs
as they are faced with simulating unrestricted nondeterminism.
No such construction exists in the case of one-way NFA,
as the NFA-to-UFA and the NFA-to-DFA tradeoffs
are practically the same (versus).
Hence, if any substantial difference could be found
between the 2NFA-to-UFA and 2NFA-to-DFA transformations,
this would be interesting indeed.

SECTION: Acknowledgements
This work was supported by the Russian Science Foundation, project 23-11-00133.

SECTION: References